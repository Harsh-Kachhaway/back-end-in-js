// Generated by CoffeeScript 1.9.3
(function() {
  var Assert, NOT_USED, ORIGINAL_VALUE, REMAIN, Should, Task, Test, md5,
    slice = [].slice,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Assert = require('assert');

  md5 = require('md5');

  REMAIN = '__REMAIN__';

  NOT_USED = '__NOT_USED__';

  ORIGINAL_VALUE = '__ORIGINAL_VALUE__';

  Test = (function() {
    function Test(title) {
      this.title = title;
      return;
    }

    Test.prototype.set = function() {
      var argv, callback, condition, name;
      name = arguments[0], argv = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      condition = void 0;
      callback = void 0;
      if (argv != null) {
        if (argv.length === 1) {
          if (typeof argv[0] === 'string') {
            condition = argv[0];
          }
          if (typeof argv[0] === 'function') {
            callback = argv[0];
          }
        }
        if (argv.length === 2) {
          if (typeof argv[0] === 'string' && typeof argv[1] === 'function') {
            condition = argv[0];
            callback = argv[1];
          }
        }
      }
      return new Task(this.title, name, condition, callback);
    };

    Test.prototype.not = function(str) {
      return "not " + str;
    };

    return Test;

  })();

  Task = (function() {
    function Task(group, name, condition, callback) {
      if (group == null) {
        throw new Error('Test group not set.');
      }
      if (name == null) {
        throw new Error('Test task name not set.');
      }
      this._group = group;
      this._name = name;
      this._condition = condition;
      this._callback = callback;
      this.EQUAL = 1;
      this.TRUE = 2;
      this.FALSE = 3;
      return;
    }

    Task.prototype.group = function(arg) {
      this._group = arg;
    };

    Task.prototype.name = function(arg) {
      this._name = arg;
    };

    Task.prototype.condition = function(arg) {
      this._condition = arg;
    };

    Task.prototype.callback = function(arg) {
      this._callback = arg;
    };

    Task.prototype.assert = function(args, expected, assertion, condition) {
      var actual;
      if (assertion == null) {
        assertion = this.EQUAL;
      }
      condition = condition != null ? condition : this._condition;
      if (condition == null) {
        switch (assertion) {
          case this.TRUE:
            condition = 'true';
            break;
          case this.FALSE:
            condition = 'false';
            break;
          default:
            condition = 'equal';
        }
      }
      condition = "should " + condition;
      actual = this.actual(args);
      describe(this._group, (function(_this) {
        return function() {
          return describe(_this._name, function() {
            return it(condition, function() {
              switch (assertion) {
                case _this.EQUAL:
                case _this.TRUE:
                case _this.FALSE:
                  return Assert.deepEqual(actual, expected);
              }
            });
          });
        };
      })(this));
    };

    Task.prototype.actual = function(args) {
      var actual;
      if (this._callback != null) {
        if (args != null) {
          actual = this._callback(args);
        } else {
          actual = this._callback();
        }
      } else {
        actual = args;
      }
      return actual;
    };

    Task.prototype.assertEqual = function(args, expected, condition) {
      this.assert(args, expected, this.EQUAL, condition);
    };

    Task.prototype.assertTrue = function(args, condition) {
      this.assert(args, true, this.TRUE, condition);
    };

    Task.prototype.assertFalse = function(args, condition) {
      this.assert(args, false, this.FALSE, condition);
    };

    Task.prototype.many = function() {
      this._many = true;
      return this;
    };

    Task.prototype.should = function(arg, condition) {
      var many, ref;
      many = (ref = this._many) != null ? ref : false;
      this._many = false;
      return new Should(this._group, this._name, arg, many, condition, this._callback);
    };

    return Task;

  })();

  Should = (function(superClass) {
    extend(Should, superClass);

    Should.prototype.__many = false;

    Should.prototype.__condition = void 0;

    function Should(group, name, args, many, condition, callback) {
      var i;
      this.__many = many;
      this.__condition = condition;
      if (group == null) {
        throw new Error('Test group not set.');
      }
      if (name == null) {
        throw new Error('Test task name not set.');
      }
      this.group(group);
      this.name(name);
      this.callback(callback);
      if (args != null) {
        this.arg = args;
        if (!this.__many) {
          this._arg_msg = this.arg_msg(args);
        } else {
          for (i in args) {
            this.arg[i].msg = this.arg_msg(args[i].args);
          }
        }
      }
      return this;
    }

    Should.prototype.arg_msg = function(arg) {
      var _arg_msg;
      _arg_msg = arg;
      if (typeof arg === 'object') {
        if (Object.prototype.toString.call(arg) === '[object Array]') {
          if (arg.length === 0) {
            _arg_msg = '[]';
          }
        } else {
          if (Object.keys(arg).length === 0) {
            _arg_msg = '{}';
          }
        }
      }
      return _arg_msg;
    };

    Should.prototype["return"] = function() {
      this._return = true;
      return this;
    };

    Should.prototype.action = function() {
      if ((this._return != null) && this._return) {
        return 'return';
      }
      return '';
    };

    Should.prototype.equal = function(arg) {
      this.expected = arg;
      if (this.__many && (arg == null)) {
        this.expected = NOT_USED;
      }
      this.done();
    };

    Should.prototype.undefined = function() {
      this.expected = void 0;
      if (this.__many && (typeof arg === "undefined" || arg === null)) {
        this.expected = NOT_USED;
      }
      this.done();
    };

    Should.prototype.set_many_default_args = function(args) {
      var i, tmp;
      for (i in this.arg) {
        tmp = this.arg[i];
        this.arg[i] = {
          args: tmp,
          expected: args !== REMAIN ? args : tmp
        };
      }
    };

    Should.prototype.remain = function() {
      this.expected = this.arg;
      if (this.__many) {
        this.set_many_default_args(REMAIN);
        this.expected = NOT_USED;
      }
      this.done(ORIGINAL_VALUE);
    };

    Should.prototype["true"] = function() {
      this.expected = true;
      if (this.__many) {
        this.set_many_default_args(true);
        this.expected = NOT_USED;
      }
      this.done();
    };

    Should.prototype["false"] = function() {
      this.expected = false;
      if (this.__many) {
        this.set_many_default_args(false);
        this.expected = NOT_USED;
      }
      this.done();
    };

    Should.prototype.done = function(msg) {
      var arg, args, j, len, many;
      msg = msg != null ? msg : this.expected;
      if (msg === NOT_USED || msg === ORIGINAL_VALUE) {
        switch (msg) {
          case NOT_USED:
            msg = 'correctly';
            break;
          case ORIGINAL_VALUE:
            msg = 'original value';
        }
        msg = (this.action()) + " " + msg;
      } else {
        msg = (this.action()) + " '" + msg + "'";
      }
      if ((this.arg != null) && !this.__many) {
        msg = msg + " on '" + this._arg_msg + "'";
      }
      if (this.__many && (this.__condition != null)) {
        msg = msg + " on " + this.__condition;
      }
      many = this.__many;
      this.__many = false;
      this.__condition = void 0;
      if (!many) {
        args = [
          {
            args: this.arg,
            expected: this.expected
          }
        ];
      } else {
        args = this.arg;
      }
      for (j = 0, len = args.length; j < len; j++) {
        arg = args[j];
        this.assertEqual(arg.args, arg.expected, msg);
      }
    };

    Should.prototype.not = function(str) {
      return "not " + str;
    };

    return Should;

  })(Task);

  module.exports = Test;

}).call(this);
